<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spring boot使用systemd部署</title>
      <link href="2020/09/18/spring-boot-shi-yong-systemd-bu-shu/"/>
      <url>2020/09/18/spring-boot-shi-yong-systemd-bu-shu/</url>
      
        <content type="html"><![CDATA[<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${spring-boot.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executable</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executable</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>repackage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span></code></pre><pre><code># -f --forceln -sf $JAVA_HOME/bin/java /sbin/java</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token function">tee</span> /etc/systemd/system/xxl-job-admin.service <span class="token operator">&lt;&lt;</span>-<span class="token string">'EOF'</span><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>定时任务服务After<span class="token operator">=</span>syslog.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>User<span class="token operator">=</span>rootRestart<span class="token operator">=</span>on-failureRestartSec<span class="token operator">=</span>10startLimitIntervalSec<span class="token operator">=</span>60Environment<span class="token operator">=</span>MYDIR<span class="token operator">=</span>/home/modularization/xxlJobAdminWorkingDirectory<span class="token operator">=</span>/home/modularization/xxlJobAdminExecStart<span class="token operator">=</span>/sbin/java -jar -Dspring.profiles.active<span class="token operator">=</span>test /home/modularization/xxlJobAdmin/xxl-job-admin-2.2.1-SNAPSHOT.jarSuccessExitStatus<span class="token operator">=</span>143<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.targetEOF</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token function">tee</span> /etc/systemd/system/messagemanager.service <span class="token operator">&lt;&lt;</span>-<span class="token string">'EOF'</span><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>消息管理程序After<span class="token operator">=</span>xxl-job-admin.serviceRequires<span class="token operator">=</span>xxl-job-admin.service<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>User<span class="token operator">=</span>rootRestart<span class="token operator">=</span>on-failureRestartSec<span class="token operator">=</span>20startLimitIntervalSec<span class="token operator">=</span>60WorkingDirectory<span class="token operator">=</span>/home/modularization/messageManagerExecStart<span class="token operator">=</span>/sbin/java -jar -Dspring.profiles.active<span class="token operator">=</span>test /home/modularization/messageManager/bdlbsc-message-manager-0.0.1-SNAPSHOT.jarSuccessExitStatus<span class="token operator">=</span>143<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.targetEOF</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># realod service</span>systemctl daemon-reload</code></pre><pre class=" language-bash"><code class="language-bash">systemctl <span class="token function">enable</span> xxl-job-adminsystemctl <span class="token function">enable</span> messagemanager</code></pre><pre class=" language-bash"><code class="language-bash">journalctl -f -u messagemanager.service</code></pre><p>有依赖关系会直接启动xxl-job-admin</p><h1 id="阿里云流水线主机部署脚本"><a href="#阿里云流水线主机部署脚本" class="headerlink" title="阿里云流水线主机部署脚本"></a>阿里云流水线主机部署脚本</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><pre><code>tee deploy.sh &lt;&lt;-'EOF'systemctl start messagemanagerEOFmvn clean package -DskipTests</code></pre><h2 id="上传路径"><a href="#上传路径" class="headerlink" title="上传路径"></a>上传路径</h2><pre><code>target/bdlbsc-message-manager-0.0.1-SNAPSHOT.jar</code></pre><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="下载路径"><a href="#下载路径" class="headerlink" title="下载路径"></a>下载路径</h3><pre><code>/home/modularization/messageManager/message-manager.tgz</code></pre><h3 id="部署脚本"><a href="#部署脚本" class="headerlink" title="部署脚本"></a>部署脚本</h3><pre><code>set -emkdir -p /home/modularization/messageManager;systemctl stop messagemanagertar xf /home/modularization/messageManager/message-manager.tgz -o -C /home/modularization/messageManager;chmod +x  /home/modularization/messageManager/deploy.sh;/home/modularization/messageManager/deploy.sh;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svn安装</title>
      <link href="2020/09/18/svn-an-zhuang/"/>
      <url>2020/09/18/svn-an-zhuang/</url>
      
        <content type="html"><![CDATA[<pre><code>yum install subversionmkdir -p /home/svn/reposvnadmin create /home/svn/repo</code></pre><p>修改<code>/home/svn/repo</code>svnserve.conf配置</p><pre><code># anon-access = read  auth-access = write  password-db = passwd  authz-db = authz  realm = /home/svn/repo</code></pre><pre><code>[groups]# harry_and_sally = harry,sally# harry_sally_and_joe = harry,sally,&amp;joeadmin = admindeveloper = developer# [/foo/bar]# harry = rw# &amp;joe = r# * =#[/home/svn/repo]#@admin = rw# [repository:/baz/fuz]# @harry_and_sally = rw# * = r[repo:/]@admin = rw* =# repo就是仓库名字，配置仓库目录下的权限[repo:/requirement]@admin = rw@developer = rw* =</code></pre><p>svn systemd部署（开机启动）</p><pre class=" language-bash"><code class="language-bash"><span class="token function">tee</span> /etc/systemd/system/svn.service <span class="token operator">&lt;&lt;</span>-<span class="token string">'EOF'</span><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>svn服务After<span class="token operator">=</span>syslog.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>User<span class="token operator">=</span>rootType<span class="token operator">=</span>forkingRestart<span class="token operator">=</span>on-failureRestartSec<span class="token operator">=</span>10ExecStart<span class="token operator">=</span>/usr/bin/svnserve --daemon --pid-file<span class="token operator">=</span>/home/svn/svn.pid -d -r /home/svnSuccessExitStatus<span class="token operator">=</span>143<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.targetEOF</code></pre><pre><code>systemctl enable svnsystemctl start svnsystemctl status svn</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grpc与graphql最佳实践</title>
      <link href="2019/10/24/grpc-yu-graphql-zui-jia-shi-jian/"/>
      <url>2019/10/24/grpc-yu-graphql-zui-jia-shi-jian/</url>
      
        <content type="html"><![CDATA[<img src="/gallery/thumbnails/graphql_grpc.png" title="graphql_grpc"><p>本文分为两部分，一部分翻译自<a href="https://john-millikin.com/effective-grpc" target="_blank" rel="noopener">effective-grpc</a>，另一部分来自于集成grpc graphql实践。</p><a id="more"></a><h1 id="Effective-grpc"><a href="#Effective-grpc" class="headerlink" title="Effective grpc"></a>Effective grpc</h1><h2 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h2><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>使用<code>google.protobuf.Status</code>消息将错误报告给客户端-gRPC库应针对您的语言对这种类型进行特殊区分（例如，grpc-go具有<a href="https://godoc.org/google.golang.org/grpc/status" target="_blank" rel="noopener">google.golang.org/grpc/status</a>)。该消息可以包含任意子消息，因此服务器可以向所有客户端提供基本错误消息，并向可以处理这些错误的客户端提供结构化错误。 有关每个错误代码的含义的详细信息，请参考<a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto" target="_blank" rel="noopener">google/rpc/code.proto</a>；有关如何编写错误消息的详细建议，请参考<a href="https://cloud.google.com/apis/design/errors" target="_blank" rel="noopener">Google Cloud Error Model</a>。</p><blockquote><p>grpc-java中为<a href="https://grpc.github.io/grpc-java/javadoc/index.html?io/grpc/Status.html" target="_blank" rel="noopener">io.grpc.Status</a></p></blockquote><h3 id="超时和截止时间"><a href="#超时和截止时间" class="headerlink" title="超时和截止时间"></a>超时和截止时间</h3><p>服务器端处理程序应始终传播截止时间，客户几乎应该总是设定截止时间。优先选择截止时间而不是超时，因为在跨网络边界工作时，绝对时间戳的含义不如相对时间模糊。 根据你的实现库，有可能在service schema中定义默认超时，不要这样做-schema创建者无法预测哪种行为适合所有实现或用户。</p><h3 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h3><p>始终遵循<a href="https://github.com/grpc/grpc/blob/master/doc/naming.md" target="_blank" rel="noopener">gRPC名称解析</a>所使用的类似URL的语法，将gRPC地址表示并存储为完整字符串。诸如<code>IP +端口元组</code>之类的限制性格式会使想要在更大的框架或集成测试中运行您的代码的用户烦恼，这些测试可能对网络地址有自己的想法。 让地址设置在命令行标志或配置文件中，以便用户可以配置它们而不必修补二进制文件。即使您确实非常确定整个世界都希望在端口80上运行服务，也要这样做。</p><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>gRPC支持单向和双向消息流，如果要传输的数据量可能很大，或者在完全接收到输入之前另一端可以有意义地处理数据，请使用流。例如，提供SHA256方法的服务可以在输入块到达时对其进行哈希处理，然后在客户端关闭请求流时将最终摘要发送回去。 与为每个块发送单独的RPC相比，流传输效率更高，但比所有块都位于重复字段中的单个RPC效率要低。流的开销可以通过使用批处理消息类型来最小化。</p><pre class=" language-proto"><code class="language-proto">service Foo {    rpc MyStream(FooRequest) returns (stream MyStreamItem);}message MyStreamItem {    repeated MyStreamValue values = 1;}message MyStreamValue {    // ... fields for each logical value}</code></pre><blockquote><p>WARNING：在某些实现中（例如grpc-go），流句柄不是线程安全的，即使是客户端存根也不是。与来自多个线程的流句柄进行交互可能会导致不可预测的行为，包括静默消息损坏。</p></blockquote><h3 id="请求-响应类型"><a href="#请求-响应类型" class="headerlink" title="请求/响应类型"></a>请求/响应类型</h3><p>在你的<code>service</code>中每个方法都应该有自己独有的请求和响应消息</p><pre class=" language-proto"><code class="language-proto">service Foo {    rpc Bar(BarRequest) returns (BarResponse);}message BarRequest  { ... }message BarResponse { ... }</code></pre><p>请不要在不同的方法中使用相同的消息，除非他们实际上是使用不同的API实现相同的方法(例如一元和流变种接收同样的响应)。即使这种情况，对于API也有可能有不同的部分，此时请新建另一个类型。</p><pre class=" language-proto"><code class="language-proto">service Foo {    rpc Bar(BarRequest) returns (BarResponse);    rpc BarStream(BarRequest) returns (stream BarResponseStreamItem);}message BarRequest  { ... }message BarResponse { ... }message BarResponseStreamItem { ... }</code></pre><p>WARNING: 请不要使用<code>google.protobuf.Empty</code>作为请求和响应类型，他的API文档中的描述<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/empty.proto" target="_blank" rel="noopener">google/protobuf/empty.proto</a>是一种反模式。如果你使用<code>Empty</code>， 那么将字段添加到请求/响应中将使所有客户端和服务器的API发生重大变化。</p><h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>使用软件包名称、项目名称、公司（如果适用）和<a href="https://semver.org/" target="_blank" rel="noopener">语义版本</a>控制主版本。确切的格式取决于个人喜好-流行的格式包括Java中使用的<a href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation" target="_blank" rel="noopener">反向域名表示法</a>，或核心gRPC类型使用的<code>$COMPANY</code>.<code>$PROJECT</code></p><ul><li><code>om.mycompany.my_project.v1</code></li><li><code>com.mycompany.MyProject.v1</code></li><li><code>mycompany.my_project.v1</code><br>尚未完全稳定的API版本应具有v1alpha，v2beta1或v3test之类的后缀。有关更详尽的指导，请参考K<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/empty.proto" target="_blank" rel="noopener">ubernetes API版本控制策略</a>。<br></li></ul><p>Protobuf软件包名称用于生成的代码中，因此请避免使用内置类型或关键字（例如return或void)等常用的名称。这对于生成C ++尤为重要，因为C ++（从protobuf 3.6起）没有<code>FileOption</code>来覆盖默认的<code>namespace</code>计算名称。</p><h3 id="import-path"><a href="#import-path" class="headerlink" title="import path"></a>import path</h3><p>尝试从原始文件的位置构建，以使导入路径与程序包名称匹配：<code>mycompany.my_project.v1</code>中的类型应与<code>import "mycompany/my_project/v1/some_file.proto"</code>一起导入。 Protobuf工具链不是必需的，但是确实可以帮助我们记住输入的内容。</p><h3 id="Next-Number-注释"><a href="#Next-Number-注释" class="headerlink" title="Next-Number 注释"></a>Next-Number 注释</h3><p>在大型protobuf消息中，弄清楚应该为新字段使用哪个字段编号可能会很烦人。为了简化将来的编辑者的工作，请在消息和枚举的末尾添加注释</p><pre class=" language-proto"><code class="language-proto">message MyMessage {    // ... lots of fields here ...    // NEXT: 42}</code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举作用域遵循旧式C/C ++规则，因此定义的名称不限于枚举名称：</p><pre><code>// symbol `FUN_LEVEL_HIGH' is of type `FunLevel'.enum FunLevel {    FUN_LEVEL_UNKNOWN = 0;    FUN_LEVEL_LOW = 1;    FUN_LEVEL_HIGH = 2;    // NEXT: 3}</code></pre><blockquote><p>枚举值不能重复，即使是在不同枚举类型中，你可能觉得这样很变态，但是事实就是这样的-_-</p></blockquote><p>对于习惯于具有更现代范围规则的语言的用户而言，这可能很别扭。我喜欢用消息包装枚举：</p><pre><code>// symbol `FunLevel::HIGH` is of type `FunLevel::Enum`.message FunLevel {    enum Enum {        UNKNOWN = 0;        LOW = 1;        HIGH = 2;        // NEXT: 3    }}</code></pre><h3 id="墓碑"><a href="#墓碑" class="headerlink" title="墓碑"></a>墓碑</h3><p>如果某个字段已被删除，则其字段编号不得再被将来的字段添加重用。通过添加带有逻辑标记的墓碑<a href="https://developers.google.com/protocol-buffers/docs/proto3#reserved" target="_blank" rel="noopener">保留字</a>来防止意外的字段号重用。我总是保留字段名称和编号:</p><pre class=" language-proto"><code class="language-proto">enum FunLevel {    // removed -- too much fun    reserved "FUN_LEVEL_EXCESSIVE"; reserved 10;}message MyMessage {    reserved "crufty_old_field"; reserved 20;}</code></pre><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>Protobuf没有用于API文档的内置生成器。在可用选项中，<a href="https://github.com/pseudomuto/protoc-gen-doc" target="_blank" rel="noopener">protoc-gen-doc</a>似乎最成熟，请查看在<a href="https://github.com/pseudomuto/protoc-gen-doc/blob/master/README.md" target="_blank" rel="noopener">protoc-gen-doc README</a>中的语法和例子</p><h2 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h2><p>Protobuf除了proto2（已在proto3中删除）所要求的之外，没有内置的验证机制。 envoyproxy的<a href="https://github.com/envoyproxy/protoc-gen-validate" target="_blank" rel="noopener">protoc-gen-validate</a>工具是我所知道的最好的解决方案</p><h3 id="可选的自定义类型"><a href="#可选的自定义类型" class="headerlink" title="可选的自定义类型"></a>可选的自定义类型</h3><p>在proto3中，删除了将标量字段（int32，字符串等）标记为可选的功能。标量字段现在始终存在，如果没有其他设置，将为默认的<code>零值</code>。当为其中<code>""</code>和<code>NULL</code>是逻辑上不同的值的系统设计架构时，这可能令人沮丧。 官方解决方法是一组在<code>Google/protobuf/wrappers.proto</code>中定义的“包装器类型”，用于定义单值消息。你的架构可以使用<code>google.protobuf.Int32Value</code>而不是<code>int32</code>来获得可选性。</p><pre class=" language-proto"><code class="language-proto">import "google/protobuf/wrappers.proto";message MyMessage {    .google.protobuf.Int32Value some_field = 1;}</code></pre><p>另一种方法是将标量字段包装为<a href="https://developers.google.com/protocol-buffers/docs/proto3#oneof" target="_blank" rel="noopener">oneof</a>，而没有其他选择.并在生成的代码中添加辅助方法以检测是否设置了该字段,来迫使标量字段具有可选性。</p><pre><code>message MyMessage {    oneof oneof_some_field {        int32 some_field = 1;    }}</code></pre><h1 id="graphql与grpc集成"><a href="#graphql与grpc集成" class="headerlink" title="graphql与grpc集成"></a>graphql与grpc集成</h1><p><a href="https://graphql.cn/" target="_blank" rel="noopener">grapql</a>是一种用于查询的api语言，跟protobuf一样同样的是使用schema描述，类型系统都是自己独有的。在与graphql和grpc集成过程最大问题就是类型问题。具体请查看<a href="https://silencecorner.github.io/2019/08/18/graphql-grpc-in-java-world-1/" target="_blank" rel="noopener">graphql和grpc集成</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graphql </tag>
            
            <tag> grpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LazyInitializationException</title>
      <link href="2019/08/19/lazyinitializationexception/"/>
      <url>2019/08/19/lazyinitializationexception/</url>
      
        <content type="html"><![CDATA[<img src="/gallery/thumbnails/unitOfWork.png" title="unitOfWork"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用reflectasm的MethodAccess调用get方法出错，报错<code>org.hibernate.LazyInitializationException: could not initialize proxy [com.bd.post.model.Post#2] - no Session</code></p><a id="more"></a><h1 id="查错过程"><a href="#查错过程" class="headerlink" title="查错过程"></a>查错过程</h1><p>使用的orm框架是<code>spring data jpa</code>，<code>LazyInitializationException</code>第一时间想到<code>hibernate</code>和<code>spring data jpa</code>的懒加载机制。我理解的懒加载的概念是<code>在真正使用数据的时候才去执行sql语句(配置外键关联)，查询对外建关联对象</code>，但是我的model配置如下：</p><pre><code>/** * @author &lt;a href="mailto:hilin2333@gmail.com"&gt;created by silencecorner 2019/7/10 3:28 PM&lt;/a&gt; */@NoArgsConstructor@Entity@Data@EntityListeners(AuditingEntityListener.class)@ProtoClass(PostProto.Post.class)public class Post {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @ProtoField    private Integer id;    @ProtoField    private String title;    @ProtoField    private String body;    @ProtoField    private Integer authorId;    @CreatedDate    @ProtoField(nullValue = ProtobufNullValueInspectorImpl.class,converter = LocalDateTimeConverterImpl.class)    private LocalDateTime createdAt;    @LastModifiedDate    private LocalDateTime updatedAt;    public Post(String title, String body) {        this.title = title;        this.body = body;    }    public Post(String title, String body, Integer authorId) {        this.title = title;        this.body = body;        this.authorId = authorId;    }}</code></pre><p>这里我并没有配置外键的关联对象呀！<br><br>具体的错误信息里面又有<code>no session</code>，在orm框架里面都有session的概念对应数据库的session，在mybatis中是<code>sqlsession</code>,spring data jpa和hibernate中就叫session。检查代码发现使用了<code>JpaRepository的getOne</code>方法获取数据</p><pre><code>  /**  * Returns a reference to the entity with the given identifier. Depending on how the JPA persistence provider is  * implemented this is very likely to always return an instance and throw an  * {@link javax.persistence.EntityNotFoundException} on first access. Some of them will reject invalid identifiers  * immediately.  *  * @param id must not be {@literal null}.  * @return a reference to the entity with the given identifier.  * @see EntityManager#getReference(Class, Object) for details on when an exception is thrown.  */  T getOne(ID id);</code></pre><p>大概的意思是，只返回一个引用，信息看异常信息，what?<br>找到调用的方法说明</p><pre><code>  /**    * Get an instance, whose state may be lazily fetched.    * If the requested instance does not exist in the database,    * the &lt;code&gt;EntityNotFoundException&lt;/code&gt; is thrown when the instance     * state is first accessed. (The persistence provider runtime is     * permitted to throw the &lt;code&gt;EntityNotFoundException&lt;/code&gt; when     * &lt;code&gt;getReference&lt;/code&gt; is called.)    * The application should not expect that the instance state will    * be available upon detachment, unless it was accessed by the    * application while the entity manager was open.    * @param entityClass  entity class    * @param primaryKey  primary key    * @return the found entity instance    * @throws IllegalArgumentException if the first argument does    *         not denote an entity type or the second argument is    *         not a valid type for that entity's primary key or    *         is null    * @throws EntityNotFoundException if the entity state     *         cannot be accessed    */  public &lt;T&gt; T getReference(Class&lt;T&gt; entityClass, Object primaryKey);</code></pre><p>这里终于说啦是懒加载，然后就是不希望这个对象变成游离态，除非entity manager打开。好吧！这里顺便回忆一下hibernate和jpa的对象状态，这些状态都是从<a href="https://martinfowler.com/eaaCatalog/unitOfWork.html" target="_blank" rel="noopener">martinfowler的工作单元/Unit of Work</a>思想得来的。这些概念都是隶属于<code>persistence coentext</code>，翻译过来就是持久化上下文，既然隶属一个上下文那肯定是有关系的。其中</p><ul><li>瞬时态/transient <blockquote><p>新new的一个就是表对象，这个对象就是瞬时态</p></blockquote></li><li>持久态/persistent <blockquote><p>执行一下save方法，这个对象就变成持久态</p></blockquote></li><li>游离态/detachment <blockquote><p>这个保存过的对象修改属性之后就变成了游离态（ps:持久态修改属性都会变成游离态)。好了，上面有一句最关键的话就是<code>unless it was accessed by the application while the entity manager was open</code>。去找一下我们的<code>EntityManager</code>接口，它是实现了<code>Session</code>接口的。很自然的就想到了事务，持久化没有事务怎么能行（我当时写的时候还真没有加，哈哈！）。</p></blockquote></li></ul><p><a href="https://github.com/silencecorner/graphql-grpc-exmaple/blob/master/post-api-java/src/main/java/com/bd/post/service/PostServiceImpl.java#L67" target="_blank" rel="noopener">代码源文件</a></p><pre><code>@Transactional@Overridepublic void updatePost(PostProto.UpdatePostRequest request, StreamObserver&lt;PostProto.Post&gt; responseObserver){  check(request);  // field_mask 填充字段  Configuration configuration = Configuration.builder().addIgnoredFields(new FieldsIgnore().add(Post.class, "authorId", "createdAt")).build();  Post post = Converter.create(configuration).toDomain(Post.class, request);  Post newPost = postRepository.getOne(post.getId());  CopyUtils.copyProperties(post, newPost, true);  responseObserver.onNext(modelToRpc(postRepository.save(newPost)));  responseObserver.onCompleted();}</code></pre><p>那么在什么场景下去使用返回<code>Optional</code>的<code>findById</code>，什么时候使用返回懒加载对象的<code>getOne</code>呢？从含义上来讲，<code>getOne</code>表示数据一定存在，可以在udpate的时候使用，而<code>findById</code> 会立刻返回结果，可能存在也可能不存在。另外，<code>getOne</code>因为是返回的是一个引用，还没有具体执行，给一种异步的感觉，可以在响应式web程序中使用返回<code>CompletableFuture</code>等封装对象，当也得符合数据必须在数据库中存在这个条件。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>懒加载需要将相应的东西保存到session，我们能控制就是加一个事务注解在方法上<code>@Transactional</code>声明这个方法没有执行完之前session不关闭。因为使用的spring boot，也可以加一个<b>不推荐使用</b>的<a href="https://vladmihalcea.com/the-hibernate-enable_lazy_load_no_trans-anti-pattern/" target="_blank" rel="noopener">配置</a>：</p><pre><code>spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true</code></pre><p>搞定</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>jdbc的中sesion和数据库的sesion的是一个东西，sesion中保存当前会话变量事务声明！在hibernate和jpa中还有一个<code>persistence coentext</code>的概念：游离态、瞬时态、持久态，这些其实都是跟session密切相关的。</p><hr><p>多看看学学还是有必要的，have a nice day ^_^!</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> issue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>graphql与grpc集成</title>
      <link href="2019/08/18/graphql-yu-grpc-ji-cheng/"/>
      <url>2019/08/18/graphql-yu-grpc-ji-cheng/</url>
      
        <content type="html"><![CDATA[<img src="/gallery/thumbnails/1_o9_bjlKXlMjii3G7BCNb-Q.png" title="架构图"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>graphql和grpc的protobuf的schema都是一个描述性文件，只是双方的具体作用有差别而已。在Java中使用schema first的<code>graphql-java-tools</code>无疑是graphql在java语言的最佳入门实践，那么问题就来啦！protobuf和graphql各自都有自己的类型系统，graphql因为会序列化为json，那么就要遵从java bean的规范（序列化框架要求），protobuf使用的builder构造对象，没有默认的构造方法。<a id="more"></a>  <br><br>本文代码仓库地址:<a href="https://github.com/silencecorner/graphql-grpc-exmaple" target="_blank" rel="noopener">https://github.com/silencecorner/graphql-grpc-exmaple</a>，如果了解<a href="https://github.com/graphql-java-kickstart" target="_blank" rel="noopener">graphql-java-kickstart</a>的代码的话，可以直接查看源代码！</p><ul><li><code>graphql-api</code> nodejs实现的网关</li><li><code>graphql-gateway-java</code> java实现的网关</li><li><code>post-api-java</code> post服务端微服务程序</li><li><code>protos</code> proto源文件</li><li><code>schema</code> graphql文件目录</li><li><code>vue-apollo-sample</code> 基于graphql规范的vue项目</li></ul><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><h4 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h4><p>因为在去年实践过一次，没有深入思考，写起来总感觉有一点别扭！所以最开始我的想法是改用nodejs来写去掉类型检查，也写过一个在<a href="https://github.com/silencecorner/graphql-grpc-exmaple/tree/master/graphql-api" target="_blank" rel="noopener">repo的graphql-api中</a></p><h4 id="converter"><a href="#converter" class="headerlink" title="converter"></a>converter</h4><p>nodejs写起来挺简单的，但是java才是主要开发语言，所以又按照去年的那个套路实现了一次，按照converter的思路使用了<a href="https://github.com/silencecorner/protobuf-converter" target="_blank" rel="noopener">protobuf-converter</a>类库,优化了一下但是还是有一些不适。</p><h4 id="jackson序列化框架"><a href="#jackson序列化框架" class="headerlink" title="jackson序列化框架"></a>jackson序列化框架</h4><p>今天我就在想能不能jackson和protobuf之间做桥接一下，google搜索了果然已经有实现的<a href="https://github.com/HubSpot/jackson-datatype-protobuf" target="_blank" rel="noopener">类库</a>，终于不用再写一遍java model啦！</p><h5 id="删除代码"><a href="#删除代码" class="headerlink" title="删除代码"></a>删除代码</h5><p>删除之前的inputs、types package，改用protobuf生成的代码，这里桥接要注入<code>ProtobufModule</code>，又想能不能直接使用返回<code>ListenableFuture</code>实例，通过查找资料可以实现。</p><h5 id="添加GraphqlToolConfiguration-java"><a href="#添加GraphqlToolConfiguration-java" class="headerlink" title="添加GraphqlToolConfiguration.java"></a>添加<code>GraphqlToolConfiguration.java</code></h5><pre><code>@Configurationpublic class GraphqlToolConfiguration {    @Bean    SchemaParserOptions options(){        ObjectMapper objectMapper = Jackson2ObjectMapperBuilder.json()            .modules(new ProtobufModule(), new Jdk8Module(), new KotlinModule(), new JavaTimeModule())            .build();        return SchemaParserOptions.newOptions()            .genericWrappers(SchemaParserOptions.GenericWrapper                .withTransformer(ListenableFuture.class,0,ListenableFuturesExtra::toCompletableFuture, type -&gt; type))            .objectMapperProvider(fieldDefinition -&gt; objectMapper )            .useDefaultGenericWrappers(true)            .build();    }}</code></pre><p>这样我们就可以使用protobuf生成的class、grpc直接返回的<code>ListenableFuture</code>，字段对应protobuf的<a href="https://developers.google.com/protocol-buffers/docs/style#message-and-field-names" target="_blank" rel="noopener">JsonName</a>，</p><h5 id="schema-graphql"><a href="#schema-graphql" class="headerlink" title="schema.graphql"></a>schema.graphql</h5><pre class=" language-graphql"><code class="language-graphql">scalar DateTime<span class="token comment" spellcheck="true"># 作者</span>type Author<span class="token punctuation">{</span>  <span class="token comment" spellcheck="true"># unique id</span>  <span class="token attr-name">id</span><span class="token punctuation">:</span> ID<span class="token operator">!</span>  <span class="token comment" spellcheck="true"># 名称</span>  <span class="token attr-name">name</span><span class="token punctuation">:</span> String<span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 添加作者参数</span>input AddAuthorRequest<span class="token punctuation">{</span>  <span class="token comment" spellcheck="true"># 名字</span>  <span class="token attr-name">name</span><span class="token punctuation">:</span> String<span class="token operator">!</span><span class="token punctuation">}</span>type Post <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true"># id</span>  <span class="token attr-name">id</span><span class="token punctuation">:</span> ID  <span class="token comment" spellcheck="true"># 标题</span>  <span class="token attr-name">title</span><span class="token punctuation">:</span> String  <span class="token comment" spellcheck="true"># 内容</span>  <span class="token attr-name">body</span><span class="token punctuation">:</span> String  <span class="token comment" spellcheck="true"># 创建时间</span>  <span class="token attr-name">createdAt</span><span class="token punctuation">:</span> DateTime  <span class="token comment" spellcheck="true"># 文章作者</span>  <span class="token attr-name">author</span><span class="token punctuation">:</span> Author<span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 分页返回结果</span>type Posts <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true"># 总数</span>  <span class="token attr-name">count</span><span class="token punctuation">:</span> Int  <span class="token comment" spellcheck="true"># 当前页</span>  <span class="token attr-name">page</span><span class="token punctuation">:</span> Int  <span class="token comment" spellcheck="true"># 条数</span>  <span class="token attr-name">limit</span><span class="token punctuation">:</span> Int  <span class="token comment" spellcheck="true"># 结点</span>  <span class="token attr-name">nodesList</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Post<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 添加文章参数</span>input AddPostRequest <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true"># 标题</span>  <span class="token attr-name">title</span><span class="token punctuation">:</span> String  <span class="token comment" spellcheck="true"># 内容</span>  <span class="token attr-name">body</span><span class="token punctuation">:</span> String<span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 分页参数</span>input ListPostRequest<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true"># 第几页</span>    <span class="token attr-name">page</span><span class="token punctuation">:</span> Int<span class="token operator">!</span>    <span class="token comment" spellcheck="true"># 获取条数</span>    <span class="token attr-name">limit</span><span class="token punctuation">:</span> Int<span class="token operator">!</span><span class="token punctuation">}</span>type Query <span class="token punctuation">{</span>  listPosts<span class="token punctuation">(</span><span class="token attr-name">request</span><span class="token punctuation">:</span> ListPostRequest<span class="token punctuation">)</span><span class="token punctuation">:</span> Posts<span class="token punctuation">}</span>type Mutation <span class="token punctuation">{</span>  addPost<span class="token punctuation">(</span><span class="token attr-name">request</span><span class="token punctuation">:</span> AddPostRequest<span class="token punctuation">)</span><span class="token punctuation">:</span> Post  <span class="token comment" spellcheck="true"># 新增作者</span>  addAuthor<span class="token punctuation">(</span><span class="token attr-name">request</span><span class="token punctuation">:</span> AddAuthorRequest<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Author<span class="token punctuation">}</span>schema <span class="token punctuation">{</span>  <span class="token attr-name">query</span><span class="token punctuation">:</span> Query  <span class="token attr-name">mutation</span><span class="token punctuation">:</span> Mutation<span class="token punctuation">}</span></code></pre><h5 id="Mutation-java"><a href="#Mutation-java" class="headerlink" title="Mutation.java"></a>Mutation.java</h5><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mutation</span> <span class="token keyword">implements</span> <span class="token class-name">GraphQLMutationResolver</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> PostClient postClient<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> AuthorClient authorClient<span class="token punctuation">;</span>    <span class="token keyword">public</span> ListenableFuture<span class="token operator">&lt;</span>PostProto<span class="token punctuation">.</span>Post<span class="token operator">></span> <span class="token function">addPost</span><span class="token punctuation">(</span>PostProto<span class="token punctuation">.</span>AddPostRequest request<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> postClient<span class="token punctuation">.</span><span class="token function">addPost</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">toBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAuthorId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ListenableFuture<span class="token operator">&lt;</span>AuthorProto<span class="token punctuation">.</span>Author<span class="token operator">></span> <span class="token function">addAuthor</span><span class="token punctuation">(</span>AuthorProto<span class="token punctuation">.</span>AddAuthorRequest request<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> authorClient<span class="token punctuation">.</span><span class="token function">addAuthor</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="Query-java"><a href="#Query-java" class="headerlink" title="Query.java"></a>Query.java</h5><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Query</span> <span class="token keyword">implements</span> <span class="token class-name">GraphQLQueryResolver</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> PostClient postClient<span class="token punctuation">;</span>    <span class="token keyword">public</span> ListenableFuture<span class="token operator">&lt;</span>PostProto<span class="token punctuation">.</span>Posts<span class="token operator">></span> <span class="token function">listPosts</span><span class="token punctuation">(</span>PostProto<span class="token punctuation">.</span>ListPostRequest request<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> postClient<span class="token punctuation">.</span><span class="token function">listPost</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="PostResolver-java"><a href="#PostResolver-java" class="headerlink" title="PostResolver.java"></a>PostResolver.java</h5><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PostResolver</span> <span class="token keyword">implements</span> <span class="token class-name">GraphQLResolver</span><span class="token operator">&lt;</span>PostProto<span class="token punctuation">.</span>Post<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> AuthorClient authorClient<span class="token punctuation">;</span>    <span class="token keyword">public</span> ListenableFuture<span class="token operator">&lt;</span>AuthorProto<span class="token punctuation">.</span>Author<span class="token operator">></span> <span class="token function">author</span><span class="token punctuation">(</span>PostProto<span class="token punctuation">.</span>Post post<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> authorClient<span class="token punctuation">.</span><span class="token function">getAuthor</span><span class="token punctuation">(</span>post<span class="token punctuation">.</span><span class="token function">getAuthorId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="repeated字段转换失败解决"><a href="#repeated字段转换失败解决" class="headerlink" title="repeated字段转换失败解决"></a><code>repeated</code>字段转换失败解决</h5><p>proto定义的是<a href="https://github.com/silencecorner/graphql-grpc-exmaple/blob/master/protos/Post.proto#L26" target="_blank" rel="noopener">nodes</a>字段，生成的java代码的get方法是<code>getNodesList</code>，此时对应的jackson的json字段就变成<code>nodesList</code>，我们的graphql中使用是<code>nodes</code>字段，按照<code>graphql-java-tools</code>的解析顺序</p><ul><li>com.bd.gateway.resolvers.post.PostsResolver.nodes(sample.PostProto$Posts)</li><li>com.bd.gateway.resolvers.post.PostsResolver.getNodes(sample.PostProto$Posts)</li><li>com.bd.gateway.resolvers.post.PostsResolver.nodes</li><li>sample.PostProto$Posts.nodes()</li><li>sample.PostProto$Posts.getNodes()</li><li>sample.PostProto$Posts.nodes</li></ul><p>同样对<code>repeated</code>修饰的请求参数同样生效，通过<a href="https://github.com/silencecorner/graphql-java-tools/commit/659d342281012653126aa1d8d9962af2f348a816" target="_blank" rel="noopener">添加graphql-java-tools List后缀匹配</a>，解决<code>repeated</code>字段桥接转换失败的问题</p><h5 id="PostClient-java"><a href="#PostClient-java" class="headerlink" title="PostClient.java"></a>PostClient.java</h5><pre><code>@Servicepublic class PostClient {    @GrpcClient("post-grpc-server")    private PostServiceGrpc.PostServiceFutureStub postServiceFutureStub;    public ListenableFuture&lt;PostProto.Post&gt; addPost(sample.PostProto.AddPostRequest request){        return postServiceFutureStub.addPost(request);    }    public ListenableFuture&lt;PostProto.Posts&gt; listPost(sample.PostProto.ListPostRequest request){        return postServiceFutureStub.listPosts(request);    }}</code></pre><h5 id="AuthorClient-java"><a href="#AuthorClient-java" class="headerlink" title="AuthorClient.java"></a>AuthorClient.java</h5><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthorClient</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GrpcClient</span><span class="token punctuation">(</span><span class="token string">"author-grpc-server"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> AuthorServiceGrpc<span class="token punctuation">.</span>AuthorServiceFutureStub authorServiceFutureStub<span class="token punctuation">;</span>    <span class="token keyword">public</span> ListenableFuture<span class="token operator">&lt;</span>AuthorProto<span class="token punctuation">.</span>Author<span class="token operator">></span> <span class="token function">addAuthor</span><span class="token punctuation">(</span>AuthorProto<span class="token punctuation">.</span>AddAuthorRequest request<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> authorServiceFutureStub<span class="token punctuation">.</span><span class="token function">addAuthor</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ListenableFuture<span class="token operator">&lt;</span>AuthorProto<span class="token punctuation">.</span>Author<span class="token operator">></span> <span class="token function">getAuthor</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> authorServiceFutureStub<span class="token punctuation">.</span><span class="token function">getAuthor</span><span class="token punctuation">(</span>AuthorProto<span class="token punctuation">.</span>GetAuthorRequest<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="new-feature"><a href="#new-feature" class="headerlink" title="new feature"></a>new feature</h3><p><a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">proto3</a>原生是不支持数据验证的，可能我们就要手写代码一个字段一个字段去做校验，项目中就会出现大量的丑陋到爆炸的代码。这里我找到一个protoc的<a href="https://github.com/envoyproxy/protoc-gen-validate" target="_blank" rel="noopener">validate plugin</a>，目前支持</p><ul><li>go</li><li>gogo </li><li>cc for c++</li><li>java</li></ul><p>以目前情况来讲，不需要多语言调用，即使出现多语言调用的情况也可以，不影响正常调用，只是缺少验证而已，再不济也可以自己实现嘛！</p><h4 id="修改proto"><a href="#修改proto" class="headerlink" title="修改proto"></a>修改proto</h4><pre class=" language-proto"><code class="language-proto">import "validate/validate.proto";message AddAuthorRequest{    string name = 1 [(validate.rules).string = {min_len: 5, max_len: 10}];}</code></pre><h4 id="修改build-gradle"><a href="#修改build-gradle" class="headerlink" title="修改build.gradle"></a>修改build.gradle</h4><h5 id="添加必要依赖"><a href="#添加必要依赖" class="headerlink" title="添加必要依赖"></a>添加必要依赖</h5><pre class=" language-gradle"><code class="language-gradle">compile "io.envoyproxy.protoc-gen-validate:pgv-java-stub:${pgvVersion}"compile "io.envoyproxy.protoc-gen-validate:pgv-java-grpc:${pgvVersion}"</code></pre><h5 id="修改编译配置"><a href="#修改编译配置" class="headerlink" title="修改编译配置"></a>修改编译配置</h5><pre class=" language-gradle"><code class="language-gradle">protobuf {    // Configure the protoc executable    protoc {        artifact = "com.google.protobuf:protoc:${protocVersion}"    }    plugins {        grpc {            artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}"        }        javapgv {            artifact = "io.envoyproxy.protoc-gen-validate:protoc-gen-validate:${pgvVersion}"        }    }    generateProtoTasks {        all()*.plugins {            javapgv {                option "lang=java"            }            grpc {}        }    }}</code></pre><h4 id="添加客户端ValidatingClientInterceptor"><a href="#添加客户端ValidatingClientInterceptor" class="headerlink" title="添加客户端ValidatingClientInterceptor"></a>添加客户端ValidatingClientInterceptor</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalClientInterceptorConfiguration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> GlobalClientInterceptorConfigurer <span class="token function">globalInterceptorConfigurerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ValidatorIndex index <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReflectiveValidatorIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> registry <span class="token operator">-</span><span class="token operator">></span> registry            <span class="token punctuation">.</span><span class="token function">addClientInterceptors</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LogGrpcInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">addClientInterceptors</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ValidatingClientInterceptor</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="服务端添加ValidatingServerInterceptor"><a href="#服务端添加ValidatingServerInterceptor" class="headerlink" title="服务端添加ValidatingServerInterceptor"></a>服务端添加ValidatingServerInterceptor</h4><pre><code>@Configurationpublic class GlobalServerInterceptorConfiguration {    @Bean    public GlobalServerInterceptorConfigurer globalInterceptorConfigurerAdapter() {        ValidatorIndex index = new ReflectiveValidatorIndex();        return registry -&gt; registry.addServerInterceptors(new ValidatingServerInterceptor(index));    }}</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>浏览器打开idea本地<a href="http://localhost:8888/playground" target="_blank" rel="noopener">http://localhost:8888/playground</a><br><br>浏览器打开docker本地<a href="http://localhost:8800/playground" target="_blank" rel="noopener">http://localhost:8800/playground</a></p><pre><code>mutation {  addAuthor(request: { name: "" }) {    id    name  }}</code></pre><p>因为名字验证规则为长度5~10，这里name值为空，执行返回结果</p><pre><code>{  "errors": [    {      "message": "INVALID_ARGUMENT: .sample.author.AddAuthorRequest.name: length must be 5 but got: 0 - Got \"\""    }  ],  "extensions": {},  "data": {    "addAuthor": null  }}</code></pre><p>生效，啦啦啦！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>介绍graphql与gprc集成的一些问题，以及如何优化做到高效舒适的编写代码。</p><p>本文代码仓库地址:<a href="https://github.com/silencecorner/graphql-grpc-exmaple" target="_blank" rel="noopener">https://github.com/silencecorner/graphql-grpc-exmaple</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graphql </tag>
            
            <tag> grpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx部署静态vue项目时的注意事项</title>
      <link href="2019/08/17/nginx-bu-shu-jing-tai-vue-xiang-mu-shi-de-zhu-yi-shi-xiang/"/>
      <url>2019/08/17/nginx-bu-shu-jing-tai-vue-xiang-mu-shi-de-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<img src="/gallery/thumbnails/vue-nginx.png" title="vue-nginx"><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在使用webpack或者vuecli3作为脚手架开发vue项目时，使用内置的express编写测试代码都没有问题，运维拿到build生成的dist文件之后，需要通过这样方式访问<code>http:/xxxx.com/content-path</code>。如何部署才能保证前端页面资源正确加载呢？</p><a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="root部署"><a href="#root部署" class="headerlink" title="root部署"></a>root部署</h3><p>假设content-path=<code>post</code>，运维同学要rename <code>dist</code>文件夹为<code>post</code>，上级文件目录<code>C:\Users\silencecorner\Project\graphql-grpc-exmaple\vue-apollo-sample</code></p><pre class=" language-bash"><code class="language-bash"><span class="token function">mv</span> dist post</code></pre><p>配置nginx.conf应该如下</p><pre class=" language-conf"><code class="language-conf">location / {    root   C:\Users\silencecorner\Project\graphql-grpc-exmaple\vue-apollo-sample;    index  index.html index.htm;}</code></pre><p>成功访问到<code>http://localhost/post/</code></p><img src="/2019/08/17/nginx-bu-shu-jing-tai-vue-xiang-mu-shi-de-zhu-yi-shi-xiang/测试.png" title="测试结果"><h3 id="alias部署"><a href="#alias部署" class="headerlink" title="alias部署"></a>alias部署</h3><p>以root部署例子为前提,那么我们的配置文件nginx.conf应该如下</p><pre class=" language-conf"><code class="language-conf">location /post {    alias   C:\Users\silencecorner\Project\graphql-grpc-exmaple\vue-apollo-sample\dist;    index  index.html index.htm;}</code></pre><p>记得执行一下<code>.\nginx.exe -s reload</code>,这是访问我们的<code>http://localhost/post/</code></p><hr><img src="/2019/08/17/nginx-bu-shu-jing-tai-vue-xiang-mu-shi-de-zhu-yi-shi-xiang/alias测试1.png" title="alias测试1结果"><p>如图访问css资源<code>http://localhost/css/app.e2707afb.css</code> 404啦，我们怎样去给这个连接下加个<code>post</code>呢？以vuecli3为例,修改<code>vue-config.js</code>添加<code>publicPath</code>指定值为<code>post</code></p><pre><code>console.log(`当前graphql网关访问地址:${process.env.VUE_APP_GRAPHQL_HTTP}`)module.exports = {    publicPath: 'post',    pluginOptions: {        graphqlMock: false,        apolloEngine: false,    },    devServer: {        port: 8081,    }}</code></pre><p>此时重新打包再次访问就能正常访问啦！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里有两种部署方式，运维上来讲更倾向于第二种，前端可以配置使用<code>process.env.XXX</code>变来获取控制台变量，运维打包时想部署到任何路径都可以啦！当然使用root方式也是能达到效果，但是可能会给运维同学造成困扰，遇到这个问题的前端同学就不要说在本地我们用<code>devServer</code>跑都没问题的这种话啦! </p><hr><p>have a nice day ^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centeros docker安装及简单应用</title>
      <link href="2019/08/16/centeros-docker-an-zhuang-ji-jian-dan-ying-yong/"/>
      <url>2019/08/16/centeros-docker-an-zhuang-ji-jian-dan-ying-yong/</url>
      
        <content type="html"><![CDATA[<h4 id="docker安裝"><a href="#docker安裝" class="headerlink" title="docker安裝"></a>docker安裝</h4><a id="more"></a><h5 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h5><pre><code>sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-selinux \                  docker-engine-selinux \                  docker-engine</code></pre><h5 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h5><p>默认安装stable版的，安装edge或者test版本的请自行查阅<a href="https://docs.docker.com/install/linux/docker-ce/centos/#install-docker-ce-1" target="_blank" rel="noopener">官方文档</a></p><pre><code>#安装配置管理工具sudo yum install -y yum-utils \  device-mapper-persistent-data \  lvm2 sudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo sudo yum install -y docker-ce</code></pre><h5 id="安装指定版本"><a href="#安装指定版本" class="headerlink" title="安装指定版本"></a>安装指定版本</h5><pre><code>yum install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpmyum install -y docker-ce-17.03.0.ce-1.el7.centos.x86_64</code></pre><h5 id="docker-加速配置（centos7"><a href="#docker-加速配置（centos7" class="headerlink" title="docker 加速配置（centos7)"></a>docker 加速配置（centos7)</h5><pre><code>sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{  "registry-mirrors": ["https://id7d29lp.mirror.aliyuncs.com"],  "insecure-registries": ["192.168.1.38:5000"]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h6 id="配置非root用户使用docker"><a href="#配置非root用户使用docker" class="headerlink" title="配置非root用户使用docker"></a>配置非root用户使用docker</h6><pre><code>#bamboo 替换成你的用户名sudo setfacl -m user:bamboo:rw /var/run/docker.sock#还有一种方式就是在加入docker的group</code></pre><h5 id="login"><a href="#login" class="headerlink" title="login"></a>login</h5><pre class=" language-bash"><code class="language-bash">docker login<span class="token comment" spellcheck="true">#你的docker hub的用户名密码</span></code></pre><p>用户名为参数登录</p><pre class=" language-bash"><code class="language-bash">docker login --username<span class="token operator">=</span>gedit registry.cn-hangzhou.aliyuncs.com<span class="token comment" spellcheck="true"># 你的ali dockerhub的密码</span></code></pre><h4 id="docker-machine"><a href="#docker-machine" class="headerlink" title="docker machine"></a>docker machine</h4><pre><code>docker-machine create -d generic --generic-ip-address=192.168.1.67 --generic-ssh-user=administrator host67</code></pre><h4 id="swarm集群"><a href="#swarm集群" class="headerlink" title="swarm集群"></a>swarm集群</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><pre><code>sudo tee /etc/sysconfig/docker &lt;&lt;-'EOF'OPTIONS='-g /cutome-path/docker -H tcp://0.0.0.0:2375'EOF</code></pre><h5 id="安装swarm"><a href="#安装swarm" class="headerlink" title="安装swarm"></a>安装swarm</h5><pre><code>docker pull swarm</code></pre><h5 id="生成token"><a href="#生成token" class="headerlink" title="生成token"></a>生成token</h5><pre><code>docker -H 192.168.1.38:8888 ps -a</code></pre><h5 id="设置管理节点"><a href="#设置管理节点" class="headerlink" title="设置管理节点"></a>设置管理节点</h5><p>在节点里面管理设置</p><pre><code> docker swarm init --advertise-addr 192.168.1.38</code></pre><h5 id="加入集群"><a href="#加入集群" class="headerlink" title="加入集群"></a>加入集群</h5><pre><code>docker swarm join \    --token SWMTKN-1-2hjlzufhptigxwvclhbn2b96rvn2ndl8wy8dqzn8otvjcibydp-7hppr5l9agyyp41wght5gpeo6 \    192.168.1.41:2377</code></pre><h5 id="查看集群节点"><a href="#查看集群节点" class="headerlink" title="查看集群节点"></a>查看集群节点</h5><pre><code>docker node ls</code></pre><h5 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h5><pre><code>docker service create --name guoi-micro-shopie-shop -p 9039:9002 -p 8940:8902 --env JAVA_OPTS="-Xmx512m" guoi/guoi-micro-shopie-shop --constraint 'node.hostname==istio-master'</code></pre><h4 id="配置本地仓库"><a href="#配置本地仓库" class="headerlink" title="配置本地仓库"></a>配置本地仓库</h4><p><a href="https://blog.csdn.net/ronnyjiang/article/details/71189392" target="_blank" rel="noopener">原文链接</a></p><pre><code>docker run -d -p 5000:5000 -v /home/docker_registry:/var/lib/registry --restart=always --name registry registry:latest  </code></pre><pre><code># insecure-registries设置本地仓库位置cat /etc/docker/daemon.json {  "registry-mirrors": ["https://7xwv2psl.mirror.aliyuncs.com"],  "insecure-registries": ["192.168.1.250:5000"]}</code></pre><p>查看仓库位置</p><pre><code>curl -XGET http://192.168.1.250:5000/v2/_catalogcurl -XGET http://192.168.1.250:5000/v2/guoi/guoi-micro-shopie-catalog/tags/list</code></pre><h4 id="jenkins-jar运行"><a href="#jenkins-jar运行" class="headerlink" title="jenkins jar运行"></a>jenkins jar运行</h4><pre><code>cd github/gedit_cloud_user_test/pid=`ps -ef | grep gedit-cloud-user-0.0.1-SNAPSHOT.jar | grep -v grep | awk '{print $2}'`if [ -n "$pid" ]then#!kill -9 强制终止   echo "kill -9 的pid:" $pid   kill -9 $pidfilsgradle build -x test -x dockerBUILD_ID=DONTKILLME #jenkins环境变量nohup java -Dspring.profiles.active=test -jar -Xmx500m build/libs/gedit-cloud-user-0.0.1-SNAPSHOT.jar &gt;&gt;/root/log/gedit_user/user.log 2&gt;&amp;1&amp;</code></pre><h4 id="docker-mysql"><a href="#docker-mysql" class="headerlink" title="docker mysql"></a>docker mysql</h4><pre><code>#dump datamysql -uroot gedit_store&gt;sqlbackup/gedit_store.docker.sqlmysql -uroot gedit_user&gt;sqlbackup/gedit_user.docker.sql#close mysqlsystemctl mysqld stop#install docker mysqldocker pull mysql #run instancedocker run -itd -p 3306:3306 mysql bash#login ttycontainer=$(docker ps|grep mysql|awk '{print $1}')docker exec -it $container bash#create databasesmysql -urootcreate database gedit_store character set utf8mb4;create database gedit_user character set utf8mb4;exit#exit ttyexit#get mysql ipmysqlIp=$(docker ps|grep mysql|awk '{print $1}'|xargs docker inspect| grep IPAddress|sed -n '2p'|awk '{print $2}'|sed -e 's/\"//g'|sed -e 's/\,//g')echo "mysql ip:$mysqlIp"#backup data,need dump mysql datamysql -uroot -h$mysqlIp gedit_store&lt;sqlbackup/gedit_store.docker.sqlmysql -uroot -h$mysqlIp gedit_user&lt;sqlbackup/gedit_user.docker.sql</code></pre><h5 id="删除none镜像"><a href="#删除none镜像" class="headerlink" title="删除none镜像"></a>删除none镜像</h5><pre><code>#delete none imagesdocker rmi -f $(docker images | grep '^&lt;none&gt;' | awk '{print $3}')</code></pre><h5 id="jenkins-docker"><a href="#jenkins-docker" class="headerlink" title="jenkins docker"></a>jenkins docker</h5><pre><code>BUILD_ID=DONTKILLMEgradle build -x test --refresh-dependenciessed 's/-Dspring.profiles.active=test/-Dspring.profiles.active=test/g' DockerfilecontainerId=$(docker ps -a|grep 'conanchen/gedit-cloud-storesearch'|awk '{print $1}')if [ $containerId ]then    echo "stop container id $containerId"    upContainerId=$(docker ps -a|grep 'conanchen/gedit-cloud-storesearch'|grep 'Up'|awk '{print $1}')    if [ $upContainerId ]    then         docker kill $upContainerId    fi    docker rm -f $containerId    docker rmi -f $(docker images|grep 'conanchen/gedit-cloud-storesearch'|awk '{print $3}')figradle build docker -x test -x dockerPushdocker run --name gedit_storesearch -d -p 9091:9090 -p 9985:9985 --env JAVA_OPTS="-Xmx512m" conanchen/gedit-cloud-storesearchsleep 30docker ps -a|grep 'conanchen/gedit-cloud-storesearch'|awk '{print $1}'|xargs docker logs</code></pre><h5 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h5><pre><code>docker pull docker.elastic.co/elasticsearch/elasticsearch:6.1.1docker run -d -it -p 19200:9200 -p 19300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms256m -Xmx512m" docker.elastic.co/elasticsearch/elasticsearch:6.1.1</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> CI/CD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
